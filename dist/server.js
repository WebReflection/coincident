var e=Promise.withResolvers.bind(Promise);let t=0;const r=t++,s=t++,n=t++,a=t++,c=t++,o=t++,i=t++,l=t++,u=t++,f=t++,h=t++,g=t++,p=t++,y=t++,b=t++;t++;const d=t++,w=t++;const m=globalThis.ImageData||class{},v=new Map(Reflect.ownKeys(Symbol).map(e=>[Symbol[e],`@${String(e)}`])),k=e=>{switch(e[0]){case"@":return Symbol[e.slice(1)];case"#":return Symbol.for(e.slice(1));case"!":return Symbol(e.slice(1));default:return Symbol()}},S=e=>v.get(e)||((e,t)=>void 0===t?"?":void 0===Symbol.keyFor(e)?`!${t}`:`#${t}`)(e,e.description),A=Object.defineProperty,B=Object.assign,T=Array.from,M=Array.isArray,U=ArrayBuffer.isView,x=(e,t)=>[e,t],O=e=>e,F={},E=e=>(t,r=new Map)=>{for(let s=0,n=t.length;s<n;s++)t[s]=e(t[s],r);return t},P=([e,t])=>0===e?t:k(t),R=e=>"string"==typeof e?x(0,e):x(16,S(e)),{getPrototypeOf:L}=Object,{construct:N}=Reflect,{toStringTag:_}=Symbol,{toString:j}=F,z=(e,t=e[_])=>t in globalThis?t:z(N(L(e.constructor),[0])),D=(e,t)=>[t?e:T(new Uint8Array(e)),e.resizable?e.maxByteLength:0],$=/\[('|")?(.+?)\1\]/g,I=(e,t)=>e?.[t];var K=(e,t)=>t.replace($,".$2").split(".").reduce(I,e),J=(e,...t)=>t.map(V,e);function V(e){return"string"==typeof e?K(this,e):this[e]}const W=globalThis.Node||class{},{apply:q,construct:Y,defineProperty:C,deleteProperty:G,get:H,getOwnPropertyDescriptor:Q,getPrototypeOf:X,has:Z,isExtensible:ee,ownKeys:te,set:re,setPrototypeOf:se}=Reflect;var ne=({reflect:e=O,transform:t=O,remote:v=O,module:A=e=>import(e),buffer:T=!1,timeout:L=-1}=F)=>{const N=(t,r=new Map)=>{if(!M(t))return t;const[s,n]=t;switch(s){case 2:{if(null===n)return globalThis;let e=r.get(t);if(!e){e=n,r.set(t,n);for(const e in n)n[e]=N(n[e],r)}return e}case 4:return r.get(t)||(r.set(t,n),j(n,r));case 8:{let t=le.get(n),r=t?.deref();return r||(t&&fe.unregister(t),r=function(...t){v.apply(this,t);for(let e=0,r=t.length;e<r;e++)t[e]=_(t[e]);return e(o,n,_(this),t).then(N)},t=new WeakRef(r),le.set(n,t),fe.register(r,n,t)),r}case 16:return k(n);default:return 1&s?ae(n):n}},_=e=>{switch(typeof e){case"object":{if(null===e)break;if(e===globalThis)return ue;const r=t(e);return ge&&he.has(r)||r instanceof m?x(0,r):U(r)?x(68,((e,t)=>{const{BYTES_PER_ELEMENT:r,byteOffset:s,buffer:n,length:a}=e;return[z(e),D(n,t),s,a!==(n.byteLength-s)/r?a:0]})(r,T)):r instanceof ArrayBuffer?x(64,D(r,T)):x(M(r)?5:3,ne(r))}case"function":return x(9,ne(t(e)));case"symbol":return x(16,S(e));case"bigint":return x(32,e.toString())}return e},j=E(N),$=E(P),I=E(R),{clear:V,id:ne,ref:ae,unref:ce}=((e=0,t=new Map,r=new Map)=>({clear:()=>{t.clear(),r.clear()},id:s=>{let n=r.get(s);if(void 0===n){for(;t.has(n=e++););t.set(n,s),r.set(s,n)}return n},ref:e=>t.get(e),unref:e=>(r.delete(t.get(e)),t.delete(e))}))(),oe=/^(?:[0-9]+|length)$/,ie=-1<L,le=new Map,ue=x(2,null),fe=new FinalizationRegistry(t=>{le.delete(t),e(r,t)});let he,ge=!1;return{assign:B,gather:J,query:K,direct:e=>(ge||(ge=!0,he=new WeakSet),he.add(e),e),evaluate:(e,...t)=>q(e,null,t),reflect(e,t,...m){const v=null===t,k=v?globalThis:ae(t);switch(e){case f:{const e=P(m[0]),t=v&&"import"===e,r=t?A:H(k,e),s=_(r);if(!ie)return s;let n,a=t,c=k;if(!t&&!(c instanceof W||M(c)&&"string"==typeof e&&oe.test(e)))if(e in k){for(;!(n=Q(c,e))&&(c=X(c),c););a=!!n&&"value"in n}else a=!0;return[a,s]}case o:{const e=new Map;return _(q(k,N(m[0],e),j(m[1],e)))}case d:return re(k,P(m[0]),N(m[1]));case p:return Z(k,P(m[0]));case b:return I(te(k),le);case i:return _(Y(k,j(m[0])));case h:{const e=Q(k,P(m[0]));if(e)for(const t in e)e[t]=_(e[t]);return e}case l:return C(k,P(m[0]),N(m[1]));case u:return G(k,P(m[0]));case g:return _(X(k));case w:return se(k,N(m[0]));case s:return void B(k,N(m[0]));case n:{const e=N(m[0]),t=Function(`return(${e}).apply(null,arguments)`);return _(q(t,null,j(m[1])))}case a:for(let e,t=0,r=(m=$(m[0],le)).length;t<r;t++)e=m[t],m[t]=_("string"==typeof e?K(k,e):k[e]);return m;case c:return _(K(k,m[0]));case r:return ce(t);case y:return ee(k)}},terminate(){for(const e of le.values())fe.unregister(e);le.clear(),V()}}};let ae=0;const ce=ae++,oe=ae++,ie=ae++,le=ae++,ue=ae++,fe=ae++,he=ae++,ge=ae++,pe=ae++,ye=ae++,be=ae++,de=ae++,we=ae++,me=ae++,ve=ae++,ke=ae++,Se=ae++,Ae=ae++,Be=ae++,Te=ae++,Me=ae++,Ue=ae++,xe=ae++,Oe=ae++,Fe=ae++,Ee=ae++,Pe=ae++,Re=ae++,Le=new TextDecoder,Ne=new TextEncoder,_e=new ArrayBuffer(8),je=new DataView(_e),ze=new Uint8Array(_e),De=(e,t,r)=>(e.set(t,r),r),$e=e=>{ze[0]=e[Je++],ze[1]=e[Je++],ze[2]=e[Je++],ze[3]=e[Je++],ze[4]=e[Je++],ze[5]=e[Je++],ze[6]=e[Je++],ze[7]=e[Je++]},Ie=e=>(ze[0]=e[Je++],ze[1]=e[Je++],ze[2]=e[Je++],ze[3]=e[Je++],je.getUint32(0,!0)),Ke=(e,t)=>{switch(e[Je++]){case ue:return $e(e),je.getFloat64(0,!0);case fe:return e[Je++];case Me:{const r=De(t,Je-1,{});for(let s=0,n=Ie(e);s<n;s++)r[Ke(e,t)]=Ke(e,t);return r}case ke:{const r=De(t,Je-1,[]);for(let s=0,n=Ie(e);s<n;s++)r.push(Ke(e,t));return r}case Oe:{const r=Je-1,s=Ke(e,t);return De(t,r,new globalThis[s](Ke(e,t)))}case Se:{const r=Je-1,s=Ie(e);return De(t,r,e.slice(Je,Je+=s).buffer)}case me:{const r=Je-1,s=Ie(e);return De(t,r,Le.decode(e.slice(Je,Je+=s)))}case Ae:return De(t,Je-1,new Date(Ke(e,t)));case Te:{const r=De(t,Je-1,new Map);for(let s=0,n=Ie(e);s<n;s++)r.set(Ke(e,t),Ke(e,t));return r}case xe:{const r=De(t,Je-1,new Set);for(let s=0,n=Ie(e);s<n;s++)r.add(Ke(e,t));return r}case Be:{const r=Ke(e,t),s=Ke(e,t),n=Ke(e,t),a=new(globalThis[r]||Error)(s);return De(t,Je-1,A(a,"stack",{value:n}))}case Fe:{const r=Ke(e,t),s=Ke(e,t),n=Ke(e,t),a=Ke(e,t),c=Ke(e,t);return De(t,Je-1,new m(r,s,n,{colorSpace:a,pixelFormat:c}))}case Ue:{const r=Ke(e,t),s=Ke(e,t);return De(t,Je-1,new RegExp(r,s))}case ce:return!1;case oe:return!0;case he:return NaN;case ge:return 1/0;case pe:return-1/0;case ye:return 0;case be:return-0;case le:return null;case de:return $e(e),je.getBigInt64(0,!0);case we:return $e(e),je.getBigUint64(0,!0);case ve:return k(Ke(e,t));case Re:return t.get(Ie(e));case Ee:{const r=Ke(e,t),s=Ke(e,t);return De(t,Je-1,new Blob([e.slice(Je,Je+=s)],{type:r}))}case Pe:{const r=Je-1,s=Ke(e,t),n=Ke(e,t),a=Ke(e,t);return De(t,r,new File([a],s,{type:a.type,lastModified:n}))}default:return}};let Je=0;class Ve{static push(e,t){e.sync(!1),e._(t,t.length)}constructor(e,t){const r=[];this.l=0,this.o=r,this.v=new Uint8Array(e,t),this.push=r.push.bind(r)}get length(){return this.l+this.o.length}sync(e){const t=this.o,r=t.length;r&&this._(e?t:t.splice(0),r)}_(e,t){const{buffer:r,byteOffset:s}=this.v,n=this.l;this.l+=t,t+=s+n,r.byteLength<t&&r.grow(t),this.v.set(e,n)}}const{isNaN:We,isFinite:qe,isInteger:Ye}=Number,{ownKeys:Ce}=Reflect,{is:Ge}=Object,He=(e,t,r)=>{const s=r.get(e),n=!s;return n?(je.setUint32(0,t.length,!0),r.set(e,[ze[0],ze[1],ze[2],ze[3]])):t.push(Re,s[0],s[1],s[2],s[3]),n},Qe=(e,t,r)=>{je.setUint32(0,r,!0),e.push(t,ze[0],ze[1],ze[2],ze[3])},Xe=(e,t,r)=>{switch(typeof e){case"number":e&&qe(e)?Ye(e)&&e<256&&-1<e?t.push(fe,e):(je.setFloat64(0,e,!0),t.push(ue,ze[0],ze[1],ze[2],ze[3],ze[4],ze[5],ze[6],ze[7])):We(e)?t.push(he):e?t.push(e<0?pe:ge):t.push(Ge(e,0)?ye:be);break;case"object":switch(!0){case null===e:t.push(le);break;case!He(e,t,r):break;case M(e):{const s=e.length;Qe(t,ke,s);for(let n=0;n<s;n++)Xe(e[n],t,r);break}case U(e):if(t.push(Oe),Xe(z(e),t,r),e=e.buffer,!He(e,t,r))break;case e instanceof ArrayBuffer:{const r=new Uint8Array(e);Qe(t,Se,r.length),et(t,r);break}case e instanceof Date:t.push(Ae),Xe(e.getTime(),t,r);break;case e instanceof Map:Qe(t,Te,e.size);for(const[s,n]of e)Xe(s,t,r),Xe(n,t,r);break;case e instanceof Set:Qe(t,xe,e.size);for(const s of e)Xe(s,t,r);break;case e instanceof Error:t.push(Be),Xe(e.name,t,r),Xe(e.message,t,r),Xe(e.stack,t,r);break;case e instanceof m:t.push(Fe),Xe(e.data,t,r),Xe(e.width,t,r),Xe(e.height,t,r),Xe(e.colorSpace,t,r),Xe(e.pixelFormat,t,r);break;case e instanceof RegExp:t.push(Ue),Xe(e.source,t,r),Xe(e.flags,t,r);break;case e instanceof File:t.push(Pe),Xe(e.name,t,r),Xe(e.lastModified,t,r);case e instanceof Blob:{const s=e.size;t.push(Ee),Xe(e.type,t,r),Xe(s,t,r);const n=t.length;et(t,new Uint8Array(s)),Ze.push(e.arrayBuffer().then(e=>[n,e]));break}default:if("toJSON"in e){const s=e.toJSON();Xe(s===e?null:s,t,r)}else{const s=Ce(e),n=s.length;Qe(t,Me,n);for(let a=0;a<n;a++){const n=s[a];Xe(n,t,r),Xe(e[n],t,r)}}}break;case"string":if(He(e,t,r)){const r=Ne.encode(e);Qe(t,me,r.length),et(t,r)}break;case"boolean":t.push(e?oe:ce);break;case"symbol":t.push(ve),Xe(S(e),t,r);break;case"bigint":{let r=de;9223372036854775807n<e?(je.setBigUint64(0,e,!0),r=we):je.setBigInt64(0,e,!0),t.push(r,ze[0],ze[1],ze[2],ze[3],ze[4],ze[5],ze[6],ze[7]);break}default:t.push(ie)}},Ze=[];let et=(e,t)=>{for(let r=e.push,s=0,n=t.length;s<n;s+=32767)r.apply(e,t.subarray(s,s+32767))};let tt=class extends ArrayBuffer{value;transferToFixedLength(e){return this.value=new ArrayBuffer(e)}};const rt=new tt,st=(({byteOffset:e=0,Array:t=Ve}={})=>(r,s)=>{const n=new t(s,e);et=t.push,Xe(r,n,new Map);const a=n.length;return n.sync(!0),Ze.length?Promise.all(Ze.splice(0)).then(t=>{const r=new Uint8Array(s,e);for(const[e,s]of t)r.set(new Uint8Array(s),e);return a}):a})({Array:class extends Ve{constructor(e,t){super(e,t),this.e=[]}sync(e){if(super.sync(e),e){const e=this.l,t=this.v.byteOffset,r=this.v.buffer.transferToFixedLength(e+t),s=new Uint8Array(r,t);for(let e=this.e,t=0,r=0;r<e.length;r++){const n=e[r];s.set(n,t),t+=n.length}}return this}_(e,t){this.l+=t,this.e.push(e)}}}),nt=async e=>await st(e,rt)?rt.value:rt,at=e=>(e=>(Je=0,Ke(e,new Map)))(new Uint8Array(e));let{SharedArrayBuffer:ct}=globalThis,ot=!0;try{new ct(4,{maxByteLength:8})}catch(e){ot=!1,ct=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}ot?crypto.randomUUID():Math.random().toString(36).substring(2);const it=(e,t=-1)=>e?.reflected_ffi_timeout??t,{String:lt}=globalThis;var ut=(t,r)=>{const[s,n]=((t=e=>e)=>{const r=new Map;let s=0;return[()=>{let n;do{n=t(s++)}while(r.has(n));const a=e();return r.set(n,a),[n,a.promise]},(e,t,s)=>{const n=r.get(e);r.delete(e),s?n?.reject(s):n?.resolve(t)}]})(lt),a=r?.import||(e=>import(e)),c=new Set;let o,i,l=e=>e,u=-1;return{direct:e=>l(e),onclose:()=>{for(const e of c)e();c.clear(),u=0,i?.()},onmessage:async e=>{if(u<0){u=0;try{const f=at(e);if(M(f)&&"=b3e5cb6e-ws"===f.at(0)){u=1;const{direct:e,reflect:f,terminate:h}=ne({...r,module:a,buffer:!0,timeout:it(r),reflect:async(...e)=>{const[r,a]=s();return t.send(await nt([r,e])),c.add(n.bind(null,r)),a}});o=f,l=e,i=h}}catch(e){}}else if(u>0){const r=at(e);if("string"==typeof r[0])n.apply(null,r);else{try{r[1]=await o(...r[1])}catch(e){r[1]=null,r[2]=e}t.send(await nt(r))}}}}},ft=(e={})=>{const{bun:t,wss:r}=e,s=new Map,n={assign(e,...t){for(const r of s.values())r.ffi.assign(e,...t);return e},evaluate(...e){for(const t of s.values())t.ffi.evaluate(...e);return value},direct(e){for(const t of s.values())t.ffi.direct(e);return e}};return t?{ffi:n,open(t){s.set(t,ut(t,e))},close(e,t,r){const n=s.get(e);s.delete(e),n.onclose(r)},message(e,t){s.get(e).onmessage(t)}}:(r&&r.on("connection",t=>{const r=ut(t,e);s.set(t,r),t.prependListener("close",(...e)=>{s.delete(t),r.onclose(...e)}),t.prependListener("message",r.onmessage)}),{ffi:n,sockets:s})};export{ft as default};
